# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

ERROR='\033[0;31m'
WARNING='\033[0;33m'
INFO='\033[0m'
DEFAULT='\033[0m'

# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

function _feedback() {
  color="${1:-DEFAULT}"
  case "${1}" in
    ERROR)
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}"
      return 1
      ;;
    WARNING)
      >&2 echo -e "${!color}${1}:  ${2}${DEFAULT}"
      return 0
      ;;
    *)
      echo -e "${!color}${1}:  ${2}${DEFAULT}"
      return 0
      ;;
  esac
}

# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

function process_security_tool_exit_status() {
  exit_code="${1}"
  security_tool="${2}"
  action="${3}"

  # If the shell is interactive, return the exit_code
  if [[ "${-}" =~ .*i.* ]]; then
    if [[ "${exit_code}" != 0 ]]; then
      _feedback ERROR "Failed ${security_tool} ${action}"
    else
      _feedback INFO "Passed ${security_tool} ${action}"
    fi

    return ${exit_code}
  # If the shell is not interactive, exit with the exit_code
  elif [[ ! "${-}" =~ .*i.* ]]; then
    if [[ "${exit_code}" != 0 ]]; then
      _feedback ERROR "Failed ${security_tool} ${action}"
    else
      _feedback INFO "Passed ${security_tool} ${action}"

      # Only skip multiple runs of the security tool when not interactive
      date +%s > "/${security_tool}_complete"
    fi

    exit ${exit_code}
  fi
}

